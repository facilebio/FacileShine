#' A dynamic list of sampleFilter modules.
#'
#' This module provides an interface that enables the user to add an abirtray
#' amount of sampleFilters that are AND-chained together to specify a cohort
#' of samples to focus analysis on. Sample filters can only be manipulated
#' (changed or removed) in a LIFO order.
#'
#' The `dataset,sample_id` sample selector that has been narrowed within the
#' returned `SampleFilterList` can be retrieved using the `active_samples()`
#' function, ie.
#'
#' ```
#' sfl <- callModule(sampleFilterList, rfds)
#' samples <- reactive(active_samples(sfl))
#' ```
#'
#' @section Implementation Notes:
#' This is implemented by dynammicaly materializing `sampleFilter` modules
#' and inserting them into the application using [shiny::insertUI()] and
#' [shiny::removeUI()].
#'
#' This implementation largely inspired from the `filter_module.R` file in Joe
#' Cheng's rpharma-demo shiny app and a post from Barret Schloerke in the
#' RStudio community forums (cf. the "See Also" section).
#'
#' Note that the UI that generated by `insertUI(ui = sampleFilterUI(ns(id)))`
#' was seemingly detached from its sister `callModule(sampleFilter, id, ...)`
#' server-side code until the `insertUI,immediate` parameter was set to `TRUE`.
#' When `immediate = FALSE`, the select inputs in the `sampleFilterUI` element
#' were not initialized/updated from within `sampleFilter` module.
#'
#' @seealso
#'   [FilteredReactiveDataStore()],
#'   [Joe Cheng's rpharm-demo app](https://github.com/jcheng5/rpharma-demo),
#'   [Barret's Post](https://community.rstudio.com/t/22617/5)
#' @export
#' @importFrom shiny insertUI removeUI setBookmarkExclude freezeReactiveValue
#' @importFrom shinyjs toggleState
#' @return A `"FacileSampleFilterList"`. Use `active_samples(this)` to retrieve
#'   the currently specified cohort of samples.
sampleFilterList <- function(input, output, session, rfds, ..., debug = FALSE) {
  ns <- session$ns
  setBookmarkExclude(c("add_filter_btn"))

  state <- reactiveValues(
    fdsname = "__initializing__",
    universe = "__initializing__",
    filters = list())

  # onBookmark(function(state) {
  #   state$values$filter_field_names <- names(filter_fields)
  # })
  #
  # onRestore(function(state) {
  #   filter_field_names <- state$values$filter_field_names
  #   for (fieldname in filter_field_names) {
  #     addFilter(fieldname)
  #   }
  # })

  # Reactivity -----------------------------------------------------------------
  # When the underyling faciledatastore changes, nuke all of the things.
  observeEvent(name(rfds), {
    req(initialized(rfds))
    name. <- name(rfds)
    if (name. != state$fdsname) {
      # Freeze the filters
      filters. <- state$filters
      state$name <- name.
      if (length(filters.) > 0) {
        # freeze all samplefilter reactivity first, then remove all
        # for (id in rev(names(filters.))) {
        #   ftrace("Freezing filter: {bold}", id, "{reset}")
        #   freezeReactiveValue(state$filters[[id]]$covariate$)
        #   removeUI(selector = paste0("#", ns(paste0(id, "_container"))),
        #            immediate = TRUE)
        # }

        for (id in rev(names(filters.))) {
          ftrace("Removing filter: {bold}", id, "{reset}")
          levels_id <- paste0(id, "-values-values")
          updateSelectizeInput(session, levels_id, choices = "", selected = "",
                               server = TRUE)
          select_id <- paste0(id, "-covariate-covariate")
          updateSelectInput(session, select_id, choices = "", selected = "")
          removeUI(selector = paste0("#", ns(paste0(id, "_container"))))
          state$filters[[id]] <- NULL
        }
      }

      # Support a restricted universe in the underlyingReactiveFacileDataStore
      if (is(rfds, "RestrictedReactiveFacileDataStore")) {
        state$universe <- collect(isolate(rfds$universe), n = Inf)
      } else {
        state$universe <- collect(isolate(samples(fds(rfds))), n = Inf)
      }
    }
  }, priority = 10)

  # TODO: re-introduce support for a restricted universe in the original
  # ReactiveFacileDataStore
  # fds.universe <- reactive({
  #   req(initialized(rfds))
  #   if (is(rfds, "RestrictedReactiveFacileDataStore")) {
  #     out <- rfds$universe
  #   } else {
  #     out <- samples(fds(rfds))
  #   }
  #   collect(out, n = Inf)
  # })
  fds.universe <- reactive({
    req(test_sample_subset(isolate(state$universe)))
    state$universe
  })

  filters <- reactive({
    state$filters
  })

  # Quick access to the last filter in the list, or NULL if no filters exist
  last.filter <- reactive({
    filters. <- filters()
    flen <- length(filters.)
    if (flen == 0) NULL else filters.[[flen]]
  })

  active.samples <- reactive({
    req(initialized(rfds))
    lf <- last.filter()
    if (is.null(lf)) fds.universe() else lf$active_samples()
  })

  # Adds a sampleFilter module when the "Add" button is pushed
  observeEvent(input$add_filter_btn, {
    req(initialized(rfds))
    filters. <- isolate(filters())
    flen <- length(filters.)

    index <- flen + 1L

    id <- paste0("sample_filter_", index)
    rmid <- paste0("remove_", id)

    if (flen == 0) {
      universe <- fds.universe
    } else {
      universe <- reactive(isolate(filters.[[flen]]$active_samples()))
    }

    # Insert UI for sampleFilter
    # Setting `immediate = TRUE` is imperative for this to work, otherwise
    # the UI elements could not be populated by its corresponding sampleFilter
    # module.
    state$filters[[id]] <- callModule(sampleFilter, id, rfds, universe)
    insertUI(
      selector = paste0("#", ns("filter_container")),
      where = "beforeEnd",
      ui = shiny::tags$div(
        id = ns(paste0(id, "_container")),
        sampleFilterUI(ns(id),
                       covariate_label = if (index == 1) "Covariate" else NULL,
                       value_label = if (index == 1) "Value(s)" else NULL)),
      immediate = TRUE)
  })

  # Removes the last sampleFilter in the list
  observeEvent(input$rm_filter_btn, {
    filters. <- filters()
    flen <- length(filters.)
    req(flen > 0)

    id <- names(filters.)[flen]

    levels_id <- paste0(id, "-values-values")
    updateSelectizeInput(session, levels_id, choices = "", selected = "",
                         server = TRUE)
    select_id <- paste0(id, "-covariate-covariate")
    updateSelectInput(session, select_id, choices = "", selected = "")

    removeUI(selector = paste0("#", ns(paste0(id, "_container"))))
    state$filters[[id]] <- NULL
  })

  # Toggle (enable/disable) web component states -------------------------------

  # The "Remove" filter button is only enabled if there is >= 1 filters present
  observe({
    toggleState("rm_filter_btn", condition = length(filters()) > 0)
  })

  # The "Add" button should only be enabled if there are no filters yet, or if
  # the current filter Value(s) is non-empty.
  observe({
    filters. <- filters()
    flen <- length(filters.)
    if (flen == 0) {
      enabled <- TRUE
    } else {
      f <- filters.[[flen]]
      enabled <- !unselected(f$values$values())
    }
    toggleState("add_filter_btn", condition = enabled)
  })

  # Ensures that only the last sampleFilter is enabled and editable by the user
  observeEvent(last.filter(), {
    filters. <- filters()
    flen <- length(filters.)
    req(flen > 0)
    for (i in seq(flen)) {
      name <- names(filters.)[i]
      enabled <- i == flen
      select_id <- paste0(name, "-covariate-covariate")
      levels_id <- paste0(name, "-values-values")
      toggleState(select_id, condition = enabled)
      toggleState(levels_id, condition = enabled)
    }
  })

  # Server Debug ---------------------------------------------------------------
  if (debug) {
    output$samples <- DT::renderDT({
      samples. <- active.samples()
      covs <- sapply(filters(), function(sf) {
        cov <- sf$covariate$covariate()
        if (unselected(cov)) cov <- ""
        cov
      })
      covs <- setdiff(covs, "")
      if (length(covs)) {
        samples. <- with_sample_covariates(samples., covs)
      }
      samples.
    }, server = TRUE)
  }

  vals <- list(
    filters = filters,
    samples = active.samples,
    .state = state,
    .ns = session$ns)
  class(vals) <- "FacileSampleFilterList"
  vals
}

#' @noRd
active_samples.FacileSampleFilterList <- function(x, ...) {
  x[["samples"]]()
}

# UI ===========================================================================

#' @noRd
#' @export
#' @importFrom shiny actionButton NS tagList tags
sampleFilterListUI <- function(id, ..., debug = FALSE) {
  ns <- NS(id)
  out <- tagList(
    tags$div(id = ns("filter_container")),
    actionButton(ns("rm_filter_btn"), "Remove Filter"),
    actionButton(ns("add_filter_btn"), "Add Filter"))

  if (debug) {
    out <- tagList(
      out,
      DT::DTOutput(ns("samples")))
  }

  out
}
