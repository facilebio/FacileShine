
#' @title Shiny module to interactively filter a `data.frame`
#'
#' @description Module generate inputs to filter `data.frame` according column's type.
#'  Code to reproduce the filter is returned as an expression with filtered data.
#'
#' @param id Module id. See [shiny::moduleServer()].
#' @param show_nrow Show number of filtered rows and total.
#' @param max_height Maximum height for filters panel, useful
#'  if you have many variables to filter and limited space.
#'
#' @return
#' * UI: HTML tags that can be included in shiny's UI
#' * Server: a `list` with four slots:
#'   + **filtered**: a `reactive` function returning the data filtered.
#'   + **code**: a `reactive` function returning the dplyr pipeline to filter data.
#'   + **expr**: a `reactive` function returning an expression to filter data.
#'   + **values**: a `reactive` function returning a named list of variables and filter values.
#'
#' @export
#'
#' @name filter-data
#' @example examples/filter_data.R
ffilter_data_ui <- function(id,
                           show_nrow = TRUE,
                           max_height = NULL) {
  ns <- shiny::NS(id)
  max_height <- if (!is.null(max_height)) {
    paste0("overflow-y: auto; overflow-x: hidden; max-height:", 
           htmltools::validateCssUnit(max_height), ";")
  }
  tagList(
    htmltools::singleton(
      tags$style(
        ".selectize-big .selectize-input {height: 72px; overflow-y: scroll;}"
      )
    ),
    if (isTRUE(show_nrow)) {
      tags$span(
        # i18n("Number of rows:"), 
        "Row count:",
        shiny::uiOutput(outputId = ns("nrow"), inline = TRUE))
    },
    shiny::uiOutput(outputId = ns("placeholder_filters"), style = max_height)
  )
}

#' @param data [shiny::reactive()] function returning a
#'  \code{data.frame} to filter.
#' @param vars [shiny::reactive()] function returning a
#'  `character` vector of variables for which to add a filter.
#'  If a named `list`, names are used as labels.
#' @param name [shiny::reactive()] function returning a
#'  `character` string representing `data` name, only used for code generated.
#' @param defaults [shiny::reactive()] function returning a
#'  named `list` of variable:value pairs which will be used to set the filters.
#' @param drop_ids Drop columns containing more than 90% of unique values, or than 50 distinct values.
#' Use `FALSE` to disable or use `list(p = 0.9, n = 50)` to customize threshold values.
#' @param widget_char Widget to use for `character` variables: [shinyWidgets::pickerInput()]
#'  or [shiny::selectInput()] (default).
#' @param widget_num Widget to use for `numeric` variables: [shinyWidgets::numericRangeInput()]
#'  or [shiny::sliderInput()] (default).
#' @param widget_date Widget to use for `date/time` variables: [shiny::dateRangeInput()]
#'  or [shiny::sliderInput()] (default).
#' @param label_na Label for missing value widget.
#' @param value_nna Default value for all NA's filters.
#'
#'
#' @rdname filter-data
#' @export
#'
#' @importFrom rlang eval_tidy %||%
ffilter_data_server <- function(id,
                                data = reactive(NULL),
                                vars = reactive(NULL),
                                name = reactive("data"),
                                defaults = reactive(NULL),
                                drop_ids = getOption("datamods.filter.drop_ids", default = TRUE),
                                widget_char = c("virtualSelect", "select", "picker"),
                                widget_num = c("slider", "range"),
                                widget_date = c("slider", "range"),
                                label_na = "NA",
                                value_na = TRUE) {
  widget_char <- match.arg(widget_char)
  widget_num <- match.arg(widget_num)
  widget_date <- match.arg(widget_date)
  
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    jns <- function(x) paste0("#", ns(x))
    
    state <- reactiveValues(
      selected_rows = TRUE)  
    
    observeEvent(data(), {
      state$selected_rows <- rep(TRUE, nrow(data()))
    })
    
    rv_filters <- reactiveValues(
      mapping = NULL,
      mapping_na = NULL,
      params = NULL)
    rv_code <- reactiveValues(expr = NULL, dplyr = NULL)
    
    # When the input `data`()-frame is updated, create the new filter UI and
    # collect stats on the universe of columns
    output$placeholder_filters <- shiny::renderUI({
      data <- data()
      req(data)
      vars <- vars()
      defaults <- defaults()
      filters <- create_filters(
        input = input,
        data = data,
        vars = vars,
        defaults = defaults,
        drop_ids = drop_ids,
        widget_char = widget_char,
        widget_num = widget_num,
        widget_date = widget_date,
        label_na = label_na,
        value_na = value_na)
      rv_filters$mapping <- filters$filters_id
      rv_filters$mapping_na <- filters$filters_na_id
      rv_filters$params <- filters$param
      filters$ui
    })
    
    # The values that are currently selected across all the filters
    filter_values <- reactive({
      data <- req(data())
      req(all(names(rv_filters$mapping) %in% names(data)))
      out <- lapply(rv_filters$mapping, function(x) {
        input[[x]]
      })
      out
    })
    
    # N/A (include/exclude) setting for each of the columns in data
    filter_nas <- reactive({
      data <- req(data())
      req(all(names(rv_filters$mapping) %in% names(data)))
      out <- lapply(rv_filters$mapping_na, function(x) {
        input[[x]]
      })
      out
    })
    
    # respond to user-filtering actions
    observe({
      data <- req(data())
      fvals <- req(filter_values())
      fnas <- req(filter_nas())
      
      selected <- isolate(state$selected_rows)

      filters <- make_expr_filter(
        filters = fvals,
        filters_na = fnas,
        data = data,
        data_name = isolate(name()) %||% "data")
      
      rv_code$expr <- filters$expr
      rv_code$dplyr <- filters$expr_dplyr
      if (is.null(filters$expr)) {
        # Nothing to rmeove/filter-out, so we need to select all rows
        result <- rep(TRUE, nrow(data))
      } else { # if (length(rv_code$expr) > 0) {
        result <- eval_tidy(expr = rv_code$expr, data = data)
      }
      if (!isTRUE(all.equal(result, selected))) {
        state$selected_rows <- result
      }
    })
    
    # Update the pickers when state$selected_rows is updated to show which
    # potential elements have been selected out.
    observeEvent(state$selected_rows, {
      
    })
    
    # The filtered dataset is updated when state$selected_rows changes
    data_filtered <- eventReactive(state$selected_rows, {
      data <- req(data())
      selected <- state$selected_rows
      if (length(selected) != nrow(data)) {
        data
      } else {
        data[selected,,drop = FALSE]
      }
    })
    
    shiny::outputOptions(x = output, name = "placeholder_filters", suspendWhenHidden = FALSE)

    output$nrow <- shiny::renderUI({
      tags$b(nrow(data_filtered()) , "/", nrow(data()))
    })
    
    list(
      filtered = data_filtered,
      values = filter_values,
      nas = filter_nas,
      code = reactive(rv_code$dplyr),
      expr = reactive(rv_code$expr))
  })
}



# Utils -------------------------------------------------------------------




#' @importFrom shiny selectizeInput sliderInput dateRangeInput
#' @importFrom stats setNames
#' @importFrom shinyWidgets pickerInput pickerOptions numericRangeInput virtualSelectInput
#' @importFrom rlang is_list
create_filters <- function(input, data,
                           vars = NULL,
                           defaults = NULL,
                           drop_ids = TRUE,
                           widget_char = c("virtualSelect", "select", "picker"),
                           widget_num = c("slider", "range"),
                           widget_date = c("slider", "range"),
                           label_na = "NA",
                           value_na = TRUE,
                           width = "100%",
                           session = getDefaultReactiveDomain()) {
  data <- as.data.frame(data)
  if (ncol(data) < 1)
    return(NULL)
  widget_char <- match.arg(widget_char)
  widget_num <- match.arg(widget_num)
  widget_date <- match.arg(widget_date)
  ns <- session$ns
  data <- drop_na(data)
  if (isTRUE(drop_ids)) {
    data <- drop_id(data)
  }
  if (is_list(drop_ids)) {
    data <- drop_id(data, n = drop_ids$n, p = drop_ids$p)
  }
  data <- dropListColumns(data)
  if (is.null(vars)) {
    vars <- names(data)
    labels <- vars
  } else {
    if (rlang::is_named(vars)) {
      labels <- names(vars)
      vars <- unname(unlist(vars))
    } else {
      labels <- vars
    }
    vars_display <- intersect(vars, names(data))
    labels <- labels[vars %in% vars_display]
    vars <- vars_display
  }

  filters_id <- paste0("filter_", makeId(vars))
  filters_id <- setNames(as.list(filters_id), vars)
  filters_na_id <- setNames(as.list(paste0("na_", filters_id)), vars)
  
  filters <- sapply(vars, function(variable) {
    var <- data[[variable]]
    any_na <- anyNA(var)
    var <- var[!is.na(var)]
    id <- filters_id[[variable]]
    label <- labels[variable == vars]
    
    default <- NULL    
    if (!is.null(defaults) && label %in% names(defaults)) {
      default <- defaults[[label]]
    }
    
    shiny::freezeReactiveValue(input, id)
    
    if (inherits(var, c("numeric", "integer"))) {
      res <- create_numeric_filter(var, ns(id), default, width, widget_num)
    } else if (inherits(var, c("Date", "POSIXct"))) {
      res <- create_date_filter(var, ns(id), default, width, widget_date)
    } else {
      res <- create_categorical_filter(var, ns(id), default, width, widget_char)
    }
    
    tag_label <- tags$span(
      htmltools::tags$label(label, class = "control-label", `for` = id),
      htmltools::HTML("&nbsp;&nbsp;"),
      if (any_na) {
        na_filter(id = ns(paste0("na_", id)), label = label_na, 
                  value = value_na)
      })
    
    list(
      ui = tags$div(
        style = "position: relative;",
        class = attr(res$ui, "container-class"),
        tag_label,
        res$ui),
      params = res$params,
      id = id,
      nsid = ns(id),
      label = label,
      any_na = any_na)
  }, simplify = FALSE)

  list(
    ui = tags$div(
      class = "datamods-filters-container",
      lapply(filters, "[[", "ui")),
    params = lapply(filters, function(x) x[setdiff(names(x), "ui")]),
    filters_id = filters_id,
    filters_na_id = filters_na_id)
}


create_numeric_filter <- function(var, id, default = NULL, width = "100%",
                                  widget = c("slider", "range")) {
  widget <- match.arg(widget)
  params <- find_range_step(var)
  params$class <- "numeric"
  
  if (!is.null(default)) {
    params$range <- default
  }
  if (identical(widget, "slider")) {
    ui <- shiny::sliderInput(
      inputId = id,
      min = params$min,
      max = params$max,
      value = params$range,
      step = params$step,
      label = NULL,
      width = width)
    ui <- set_slider_attr(ui)
  } else {
    ui <- shinyWidgets::numericRangeInput(
      inputId = id,
      value = params$range,
      label = NULL,
      width = width)
  }
  
  list(ui = ui, params = params)
}

create_date_filter <- function(var, id, default = NULL, width = "100%", 
                               widget = c("slider", "range")) {
  widget <- match.arg(widget)
  var <- pretty(var)
  range_var <- range(var)
  
  if (!is.null(default)) {
    range_var <- default
  }
  
  if (identical(widget, "slider")) {
    ui <- shiny::sliderInput(
      inputId = id,
      min = range_var[1],
      max = range_var[2],
      value = range_var,
      label = NULL,
      width = width,
      timezone = if (inherits(var, "POSIXct")) format(var[1], format = "%z"))
    ui <- set_slider_attr(ui)
  } else {
    range_var <- format(range_var, format = "%Y-%m-%d")
    ui <- shiny::dateRangeInput(
      inputId = id,
      min = range_var[1],
      max = range_var[2],
      start = range_var[1],
      end = range_var[2],
      label = NULL,
      width = width)
  }
  
  params <- list(class = "date", range = range_var)
  list(ui = ui, params = params)
}

create_categorical_filter <- function(var, id, default = NULL, width = "100%",
                                      widget = c("virtualSelect", "select", "picker")) {
  widget <- match.arg(widget)
  choices.all <- table(var)
  choices.all <- data.frame(
    variable = names(choices.all),
    count = unname(choices.all))
  params <- list(class = "character", universe = choices.all)
  choices <- choices.all$variable
  if ("" %in% choices) {
    choices <- append(choices, .empty_field_char)
  }
  choices <- tryCatch(choices[trimws(choices) != ""], error = function(e) {
    Encoding(choices[!validEnc(choices)]) <- "unknown"
    choices
  })
  selected <- choices
  if (!is.null(default)) {
    selected <- default
  }
  
  if (identical(widget, "picker")) {
    ui <- shinyWidgets::pickerInput(
      inputId = id,
      choices = choices,
      selected = selected,
      label = NULL,
      multiple = TRUE,
      width = width,
      options = shinyWidgets::pickerOptions(
        container = "body",
        actionsBox = TRUE,
        selectedTextFormat = "count",
        liveSearch = TRUE))
  } else if (identical(widget, "virtualSelect")) {
    ui <- shinyWidgets::virtualSelectInput(
        inputId = id,
        choices = choices,
        selected = selected,
        label = NULL,
        multiple = TRUE,
        width = width,
        # custom
        search = TRUE,
        showSelectedOptionsFirst = TRUE,
        # end custom
        showValueAsTags = TRUE,
        zIndex = 9999,
        dropboxWrapper = paste0("#", ns("placeholder_filters"), " .datamods-filters-container"),
        html = TRUE)
  } else {
    ui <- shiny::selectizeInput(
      inputId = id,
      choices = choices,
      selected = selected,
      label = NULL,
      multiple = TRUE,
      width = width,
      options = list(plugins = list("remove_button")))
    attr(ui, "container-class") <- "selectize-big"
  }
  
  list(ui = ui, params = params)
}

tagSetAttributes <- function(tag, ...) {
  tag$attribs[names(list(...))] <- NULL
  tag$attribs <- c(tag$attribs, list(...))
  tag
}

set_slider_attr <- function(slider) {
  slider$children[[2]] <- tagSetAttributes(
    tag = slider$children[[2]],
    `data-force-edges` = "true",
    `data-grid-num` = "4"
  )
  slider
}

na_filter <- function(id, label = "NA", value = TRUE) {
  tags$span(
    style = "position: absolute; right: 0px; margin-right: -20px;",
    shinyWidgets::prettySwitch(
      inputId = id,
      label = label,
      value = value,
      slim = TRUE,
      status = "primary",
      inline = TRUE
    )
  )
}


#' @importFrom rlang expr sym
make_expr_filter <- function(filters, filters_na, data, data_name) {
  expressions <- lapply(
    X = names(filters),
    FUN = function(var) {
      values <- filters[[var]]
      nas <- filters_na[[var]]
      data_values <- data[[var]]
      if (!is.null(values) & !match_class(values, data_values))
        return(NULL)
      values_expr <- NULL
      if (inherits(x = values, what = c("numeric", "integer"))) {
        data_range <- find_range_step(data_values)$range
        if (!isTRUE(all.equal(values, data_range))) {
          if (isTRUE(nas)) {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] | is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          } else {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] & !is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          }
        }
      } else if (inherits(x = values, what = c("Date", "POSIXct"))) {
        date_fmt <- if (inherits(values, "Date")) {
          "%Y-%m-%d"
        } else {
          "%Y-%m-%d %H:%M:%S"
        }
        data_values <- pretty(data_values)
        data_range <- range(data_values, na.rm = TRUE)
        data_range <- format(data_range, format = date_fmt, tz = "UTC")
        if (!identical(format(values, format = date_fmt, tz = "UTC"), data_range)) {
          values <- format(values, format = date_fmt)
          if (isTRUE(nas)) {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] | is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          } else {
            if (anyNA(data_values)) {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2] & !is.na(!!sym(var)))
            } else {
              values_expr <- expr(!!sym(var) >= !!values[1] & !!sym(var) <= !!values[2])
            }
          }
        }
      } else {
        data_values <- unique(as.character(data_values))
        if (.empty_field_char %in% values)
          values[which(values == .empty_field_char)] <- ""
        if (!identical(sort(values), sort(data_values))) {
          if (length(values) == 0) {
            if (isTRUE(nas)) {
              values_expr <- expr(is.na(!!sym(var)))
            } else {
              values_expr <- expr(!(!!sym(var) %in% !!data_values[!is.na(data_values)]) & !is.na(!!sym(var)))
            }
          } else {
            if (length(values) <= length(data_values)/2) {
              if (isTRUE(nas)) {
                if (anyNA(data_values)) {
                  values_expr <- expr(!!sym(var) %in% !!values | is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!!sym(var) %in% !!values)
                }
              } else {
                values_expr <- expr(!!sym(var) %in% !!values)
              }
            } else {
              if (isTRUE(nas)) {
                if (anyNA(data_values)) {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)) | is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)))
                }
              } else {
                if (anyNA(data_values)) {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)) & !is.na(!!sym(var)))
                } else {
                  values_expr <- expr(!(!!sym(var) %in% !!setdiff(data_values[!is.na(data_values)], values)))
                }
              }
            }
          }
        }
      }
      if (is.null(values_expr) & !isTRUE(nas) & anyNA(data_values)) {
        expr(!is.na(!!sym(var)))
      } else {
        values_expr
      }
    }
  )
  expressions <- lapply(
    X = expressions,
    FUN = function(expr) {
      res_expr <- try(eval_tidy(expr = expr, data = data), silent = TRUE)
      if (inherits(res_expr, "try-error"))
        return(expr)
      if (isTRUE(all(res_expr)))
        return(NULL)
      expr
    }
  )
  expressions <- dropNullsOrEmpty(expressions)
  data_name <- as.character(data_name)
  if (grepl("::", data_name)) {
    data_name <- str2lang(data_name)
  } else {
    data_name <- sym(data_name)
  }
  expr_dplyr <- Reduce(
    f = function(x, y) expr(!!x %>% filter(!!y)),
    x = expressions,
    init = expr(!!data_name)
  )
  expression <- Reduce(
    f = function(x, y) expr(!!x & !!y),
    x = expressions
  )
  return(list(
    expr_dplyr = expr_dplyr,
    expr = expression
  ))
}

#' @importFrom rlang is_double
drop_id <- function(data, p = 0.9, n = 50) {
  p <- as.numeric(p)
  if (!is_double(p, n = 1))
    p <- 0.9
  n <- as.numeric(n)
  if (!is_double(n, n = 1))
    n <- 50
  data[] <- lapply(
    X = data,
    FUN = function(x) {
      if (inherits(x, c("factor", "character"))) {
        values <- unique(as.character(x))
        values <- tryCatch(
          values[trimws(values) != ""],
          error = function(e) {
            Encoding(values[!validEnc(values)]) <- "unknown"
            values
          }
        )
        if (length(values) <= 1)
          return(NULL)
        if (isTRUE(length(values) >= (length(x) * p)))
          return(NULL)
        if (isTRUE(length(values) >= n))
          return(NULL)
      }
      x
    }
  )
  data
}

drop_na <- function(data) {
  data[] <- lapply(
    X = data,
    FUN = function(x) {
      if (all(is.na(x)))
        return(NULL)
      x
    }
  )
  data
}


# borrowed from shiny
hasDecimals <- function (value) {
  truncatedValue <- round(value)
  return(!identical(value, truncatedValue))
}

find_range_step <- function(x) {
  max <- max(x, na.rm = TRUE)
  min <- min(x, na.rm = TRUE)
  range <- max - min
  if (range < 2 || hasDecimals(min) || hasDecimals(max)) {
    pretty_steps <- pretty(c(min, max), n = 100, high.u.bias = 1)
    n_steps <- length(pretty_steps) - 1
    list(
      range = range(pretty_steps),
      min = min(pretty_steps),
      max = max(pretty_steps),
      step = signif(digits = 10, (max(pretty_steps) - min(pretty_steps))/n_steps)
    )
  }
  else {
    list(
      range = range(x, na.rm = TRUE),
      min = min,
      max = max,
      step = 1
    )
  }
}

match_class <- function(x, y) {
  char <- c("character", "factor")
  num <- c("numeric", "integer")
  date <- c("Date", "POSIXt")
  if (inherits(x, num) & inherits(y, num))
    return(TRUE)
  if (inherits(x, char) & inherits(y, char))
    return(TRUE)
  if (inherits(x, date) & inherits(y, date))
    return(TRUE)
  return(FALSE)
}


.empty_field_char <- "\u3008 \U0001d626\U0001d62e\U0001d631\U0001d635\U0001d63a \U0001d627\U0001d62a\U0001d626\U0001d62d\U0001d625 \u3009"
