% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R, R/reactiveFacileDataStore-module.R
\name{active_assays}
\alias{active_assays}
\alias{active_covariates}
\alias{active_samples}
\alias{reactiveFacileDataStore}
\title{Creates a (swappable) ReactiveFacileDataSet}
\usage{
active_assays(x, ...)

active_covariates(x, ...)

active_samples(x, ...)

reactiveFacileDataStore(
  intput,
  output,
  session,
  path,
  user = Sys.getenv("USER"),
  ...,
  restrict_samples. = NULL,
  debug = FALSE
)
}
\arguments{
\item{path}{A "reactive string" that points to the url/directory to
instantiate the ReactiveFacileDataStore from.}
}
\description{
This module creates a reactive container for a FacileDataStore, by providing
a (reactive) \code{path} parameter that points to an accessible FacileDataStore.
The reactivity of this input parameter allows the datastore to be swapped out
"live".
}
\details{
The object returned by this module is a facade for a FacileDataStore. It
needs to define implementation for the FacileData API. Most of the time this
will simply be a pass-through to the same function call on the internal
fds() of this thing, the exception is the implementations of
fetch_sample_covariates and whatever function we use to enable feature
brushing (ie. new gene set definitions).

To restrict the set of samples "in play" for the datastore, for instance when
invoking an interactive gadget over these samples, the analyst (or gadget)
can do, you can pass in a sample descriptor into the \code{restrict_samples.}
parameter. This parameter isn't reactive and isn't really meant to be
used outside of the simple context of pulling up a subset of a
FacileDataStore for interrogation via a gadget.

To allow interactive expansion and collapse of samples in play while
interactively working with a FacileDataStore with shiny, you should use
the \code{\link[=filteredReactiveDataStore]{filteredReactiveDataStore()}} module.
}
\section{Custom Sample Annotations}{

Analysts may uncover interesting subsets of samples (outliers, subtypes)
within a dataset during the course of an exploratory analysis. This object
supports downstream modules to add sample annoations via the use of the
\code{\link[=update_reactive_covaraites]{update_reactive_covaraites()}} function.

These annotations are stored in an eav table that looks a lot like the
eav_covariates table returned from \code{\link[FacileData:fetch_sample_covaraites]{FacileData::fetch_sample_covaraites()}}.
The columns are:
\itemize{
\item \code{dataset}; \code{sample_id}: the primary key of the sample
\item \code{variable}: the name of the variable -- users create this during brushin
\item \code{value}: the value of the variable
\item \code{class}: categorical or real (just categorical is supported for now)
\item \code{source}: the name (namespace) of the module that is adding the covariate
}
}

\section{Custom Feature Annotations}{

This will largely look like a GeneSetDb, with the following columns:
\itemize{
\item \code{collection}: the feature-annotation-module namespace
\item \code{name}: is the name of the featureset (provided by the uesr)
\item \code{feature_id}: the feature_id of the thing
\item \code{feature_type}: the "feature space" these features (entrez, ensgid, etc.),
these values need to be one of the elements returned from calling
\code{\link[FacileData:feature_types]{FacileData::feature_types()}} on the internal \code{datastore}.
}
}

